---
comments: true
---

# 数据链路层
> 数据链路层（Data Link Layer）是OSI模型的第二层，主要负责在物理层提供的原始比特流上建立、维护和终止数据链路连接。它确保数据在网络节点之间可靠地传输，并处理错误检测和纠正。

!!! definition "链路、数据链路和帧"
    === "链路(Link)"
        + **链路**：链路是指连接两个网络设备（如计算机、路由器、交换机等）之间的通信路径。链路可以是有线的（如以太网电缆、光纤）或无线的（如Wi-Fi、蓝牙）。链路的主要作用是传输数据帧，确保数据在两个设备之间正确传递。

        + 当真正进行通信时,两个设备之间的传输可能经过了许多链路

    === "数据链路(Data Link)"
        + **数据链路**：数据链路可以说是链路加上一些软硬件.这些软硬件实现了传输数据必需的通信协议.

        + 数据链路层的主要功能包括：

            - 帧的封装和解封装

            - 地址寻址

            - 错误检测和纠正

            - 流量控制

            - 链路管理

    === "帧(Frame)"
        + **帧**：帧是数据链路层传输的基本单位,是数据链路层的PDU(Protocol Data Unit,协议数据单元).帧通常包含以下几个部分:

            - 帧头(Header): 包含控制信息，如源地址、目的地址、类型字段等。

            - 数据部分(Payload): 包含实际传输的数据。

            - 帧尾(Trailer): 通常包含错误检测码，如循环冗余校验(CRC)码。

## 数据链路层的三个重要问题

### 封装成帧和透明传输

当数据链路层接收到来自网络层的数据包时,它需要将数据包封装成帧.封装成帧是指在一段数据的前后分别添加首部和尾部,构成帧.

<div style="text-align: center;">
    <img src="../../../image/mac152.png" alt="封装成帧" width="60%">
    <br>
    <caption>封装成帧</caption>
</div>

以太网的帧格式如下:

| 前同步码 | 帧开始定界符 | 目的MAC地址 | 源MAC地址 | 类型/长度 | 数据 | FCS(帧校验序列) |
|:------:|:------------:|:-----------:|:---------:|:---------:|:----:|:--------------:|
| 7字节  | 1字节        | 6字节       | 6字节     | 2字节     | 46~1500字节 | 4字节         |

- **前导码**：用于接收端同步。

- **帧开始定界符**：标志帧的开始。

- **目的/源MAC地址**：标识收发双方。

- **类型/长度**：指示上层协议类型或数据长度。

- **数据**：实际传输的数据。

- **FCS**：用于差错检测的循环冗余校验码。位于尾部

| 标志字段 | 地址字段 | 控制字段 | 协议字段 | 信息字段 | FCS(帧校验序列) | 标志字段 |
|:--------:|:--------:|:--------:|:--------:|:--------:|:----------------:|:--------:|
| 1字节    | 1字节    | 1字节    | 2字节    | 0~1500字节 | 2字节           | 1字节    |

- **标志字段**：帧的开始和结束标志，固定为`0x7E`。

- **地址字段**：通常为`0xFF`，表示广播地址。

- **控制字段**：通常为`0x03`，表示无编号信息帧。

- **协议字段**：指示信息字段中封装的数据类型（如IP、LCP等）。

- **信息字段**：实际传输的数据。

- **FCS**：帧校验序列，用于差错检测。位于帧的尾部。

从上面所示，可以发现，并不是每一种数据链路层协议的帧都包含有帧定界标志（即帧头和帧尾），比如以太网帧就没有。这是因为以太网帧采用了**前导码**来实现帧定界。

- **前导码**：由前同步码加上帧开始定界符组成。其作用是让接收方能够识别出帧的开始位置，从而实现帧定界。

- **帧间间隔**：以太网还有帧间间隔的概念，即两帧之间必须有一个最小的时间间隔（发送96比特需要的时间），以确保接收方能够正确识别出帧的边界。

为了提高传输效率，我们总是希望帧的数据载荷越大越好。但实际上，帧的数据载荷是有最大值限制的。这个限制就是**最大传输单元(MTU,Maximum Transmission Unit)**。不同的数据链路层协议有不同的MTU值。

---

另一方节点在接收到帧后，需要进行**解封装**，提取出数据包并交给网络层处理。解封装依靠的是帧头和帧尾中的控制信息。

> 这里存在一个问题：  
> 如果数据部分中恰好包含了和帧头或帧尾相同的比特序列，接收方在解封装时就会误以为数据部分的内容是帧头或帧尾，从而导致解封装错误。

为了解决这个问题，数据链路层需要实现**透明传输**.透明传输是指数据链路层对上层交付下来的协议数据单元PDU没有任何限制，就好像数据链路层不存在一样。

一般使用类似于转义字符的机制来实现透明传输.对于PPP,我们使用**字节填充(Byte Stuffing)**来实现透明传输.

<div style="text-align: center;">
    <img src="../../../image/mac154.png" alt="字节填充" width="60%">
    <br>
    <caption>字节填充</caption>
</div>


而对于HDLC,我们使用**比特填充(Bit Stuffing)**来实现透明传输.

<div style="text-align: center;">
    <img src="../../../image/mac153.png" alt="字节填充" width="60%">
    <br>
    <caption>比特填充</caption>
</div>

在这个上图中，帧的开始和结束都使用了一个特殊的比特序列 **01111110**作为标志。

我们使用比特填充规则 (又称“零比特填充法”)：

- 发送端：在扫描整个数据载荷时，只要连续出现5个1，就立即在后面填充一个0。

- 接收端：在接收数据时，只要发现连续的5个1，就检查其后的第6个比特。

- 如果第6个比特是 0，则说明这个0是发送端填充的，将其删除，恢复原始数据。

- 如果第6个比特是 1，则继续向后检查第7个比特。若是0（即01111110），则表明这是一个帧定界符；否则表示出现了错误。

### 差错检测

在传输过程中，数据可能会因为噪声、干扰等原因发生错误。为了保证数据的完整性，数据链路层需要实现差错检测。

错误分为两种类型：

- **位错**：单个比特发生错误，如0变1或1变0。
- **帧错**：帧丢失或帧顺序错误。

---

为了实现差错检测，在帧尾部通常会有纠错码。常见的有以下几种：

- **奇偶校验**：在数据中添加一个额外的比特，使得数据中1的个数为奇数或偶数。接收端通过检查1的个数来检测错误。
    - **奇校验**：使得数据中1的个数为奇数。
    - **偶校验**：使得数据中1的个数为偶数。
    - 很显然，出现偶数位的错误就无法检测。

- **循环冗余校验（CRC）**：将数据视为一个二进制多项式，通过多项式除法计算出一个余数，将余数附加在数据后面作为校验码。接收端通过重新计算余数来检测错误。

!!! example "CRC计算示例"
    设发送的数据为 `101001000`，生成多项式为 `1101`（即 $x^3 + x^2 + 1$）。

    1. 在数据后面添加3个0（生成多项式的最高次幂），得到 `101001000000`。

    2. 使用二进制除法对 `101001000000` 除以 `1101`，得到余数 `001`。

    3.去掉第一步添加的0,将余数附加在数据后面，得到最终发送的帧 `101001000001`。

    接收端收到帧后，对 `101001000001` 除以 `1101`，如果余数为0，则表示没有错误；否则表示有错误。

    需要注意的是:

    1. **多项式必须要有最低次项**

    2. **余数的位数应与生成多项式最高次数相同，如果位数不够，则在余数前补0来凑足位数**

    ??? note "二进制除法"
        二进制除法与十进制除法类似，但只使用0和1进行计算。主要步骤如下：

        1. 将被除数的前几位与除数对齐。

        2. 如果被除数的当前位大于等于除数，则进行异或操作（相当于减法），并将结果写在下一行。

        3. 将下一位下拉，继续与除数对齐，重复步骤2，直到处理完所有位。

        4. 最终剩下的部分即为余数。

        <div style="text-align: center;">
            <img src="../../../image/mac155.png" alt="二进制除法示例" width="60%">
            <br>
            <caption>二进制除法示例</caption>
        </div>

#### 海明码

海明码（Hamming Code）是一种用于错误检测和纠正的编码方法。它通过在数据中添加冗余位来实现错误检测和纠正。海明码能够检测并纠正单个比特错误，适用于需要高可靠性的通信系统。

海明码的基本原理如下：

1. **位置编号**：将数据位和冗余位的位置编号，从1开始。冗余位的位置是2的幂次方（即1, 2, 4, 8, ...）。

2. **冗余位计算**：每个冗余位负责检查特定位置的数据位。具体来说，第i个冗余位检查所有位置编号中第i位为1的位置。例如，第1个冗余位检查位置1, 3, 5, 7, ...，第2个冗余位检查位置2, 3, 6, 7, ...，以此类推。

3. **奇偶校验**：每个冗余位的值通过对其负责检查的数据位进行奇偶校验计算得出。如果数据位中1的个数为奇数，则冗余位设为1；否则设为0。

4. **错误检测和纠正**：接收端通过重新计算冗余位来检测错误。如果某个冗余位的计算结果与接收到的冗余位不符，则说明对应的数据位发生了错误。通过组合所有冗余位的错误信息，可以确定具体哪个数据位出错，并进行纠正。例如,如果第1和第3个冗余位检测到错误，而第2个冗余位没有检测到错误，则说明错误位置为$101_2=5_{10}$.

- [ ] 例子以后再补

---


### 可靠传输

- **可靠传输**: 实现无论发送方发送什么,接收方都能正确无误地接收到.可靠传输通常通过以下方法实现:

    - **确认和重传**：接收方在成功接收到数据后,发送一个确认(ACK)给发送方.如果发送方在超时时间内没有收到确认,则重传数据.

    - **序列号**：为每个数据帧分配一个唯一的序列号,接收方通过序列号来检测丢失或重复的帧.

    - **流量控制**：防止发送方发送数据过快,使接收方来不及处理.常用的方法有滑动窗口协议.

- **不可靠传输**: 直接丢弃有误码的帧,不进行重传.


在实际传输中,可能出现多种差错情况:

- 误码

- 分组丢失

- 分组重复

- 分组失序

其中误码出现在数据链路层及其下层,而分组丢失、分组重复和分组失序主要出现在网络层及其以上层次.

---

使用确认和重传这两种机制的可靠传输协议，通常被称为**自动重传请求（ARQ, Automatic Repeat reQuest）**。这里的“自动”意味着重传是由协议自动处理的，接收方无需显式地向发送方请求重传。

在ARQ协议中，数据帧和确认帧都必须进行编号。这样，接收方才能明确哪个确认帧对应哪个数据帧，发送方也才能知道哪些数据帧尚未被确认。

ARQ协议主要分为以下三种：

1.  **停止-等待协议（Stop-and-Wait）**

2.  **后退N帧协议（Go-Back-N, GBN）**

3.  **选择重传协议（Selective Repeat, SR）**

!!! tip "通用性"
    值得注意的是，这三种可靠传输协议的基本原理并不仅限于数据链路层，它们同样广泛应用于其上各层，尤其是传输层。

#### 停止-等待协议

停止-等待协议是最简单的ARQ协议。其工作原理如下：

1. 发送方发送一个数据帧后，停止发送，等待接收方的确认。

2. 接收方收到数据帧后，发送一个确认帧(ACK)给发送方。

3. 发送方收到确认帧后，发送下一个数据帧。

4. 如果发送方在超时时间内没有收到确认帧，或者接受到NAK(否定确认)，则重传该数据帧。
    - 相关的概念有RTO(重传超时时间,Retransmission Timeout),略大于往返时间RTT(Round Trip Time)

<div style="text-align: center;">
    <img src="../../../image/mac156.png" alt="停止-等待协议" width="60%">
    <br>
    <caption>停止-等待协议</caption>
</div>


由于停止-等待协议“发一帧，等一帧”的特性，我们只需要区分当前帧与上一帧即可。因此，该协议采用1比特的序列号就足够了，这通常被称为**自动重传请求（ARQ）的交替位协议（Alternating-Bit Protocol）**。

- **帧编号**：发送的帧交替使用序列号0和1来标识。

- **确认机制**：确认帧（ACK）同样需要编号，以明确是对哪个数据帧的确认。例如，`ACK0` 表示对序列号为0的数据帧的确认，`ACK1` 则是对序列号为1的数据帧的确认。

通过这种简单的编号机制，协议可以有效处理异常情况：

- **处理重复帧**：如果接收方连续收到两个序列号相同的数据帧，则表明发送方进行了超时重传。此时，接收方会丢弃重复的帧，并重新发送上一个确认帧。

- **处理重复或延迟的确认**：如果发送方在发送 `DATA1` 后，收到了一个 `ACK0`，它就知道这是一个对先前 `DATA0` 的重复或延迟确认，应予以丢弃。

!!! success "缓冲区的作用"
    为了实现超时重传，发送方必须设置一个**发送缓冲区**。
    
    当发送方发送完一个数据帧后，它必须在发送缓存中保留该数据帧的副本。只有在明确收到了对方发来的、对应正确序列号的确认帧（ACK）后，发送方才能清空缓存中的这个副本，准备发送下一帧。

若假设传输数据的时间是`Tt`，往返时间是`RTT`，发送`ACK`的时间忽略不计，则信道利用率为:

$$ U = \frac{Tt}{Tt + RTT} $$

在`Tt`远小于`RTT`的情况下，信道利用率会非常低。这是停止-等待协议的一个主要缺点。