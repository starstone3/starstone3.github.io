---
comments: true
---

# 索引

## Basic Concepts

- 索引是一个数据结构，用于加速对数据库表中数据的访问。

- Search Key: 索引的关键字，用于查找数据。
- 一个Index File包含多个Index Entry，每个Index Entry包含一个Search Key和一个指向数据记录的指针。
    - | Search Key|Record Pointer |

- 有两种索引类型:

    - Ordered Index: 索引条目按顺序排列，适用于范围查询。

    - Hash Index: 索引条目无序排列，适用于等值查询。


### Index Evaluation Metrics
> 索引的评估指标

- Access types supported efficiently.  E.g., 
    - Point query: records with a specified value in the attribute,点查询
    
    - Range query: or records with an attribute value falling in a specified range of values,范围查询

- Access time

- Insertion time

- Deletion time

- Space overhead

## Ordered Indices

> Indexes that are ordered by the search key.

有如下的概念:

- Primary Index(主索引): 也称为clustering index（聚集索引）.决定了排列顺序的索引,其Search Key通常,但并不一定,是主键.主索引的记录在文件中是有序的.
    <div align="center">
    <img src="../../../image/i200.png" width="100%"></div>



- Secondary Index(次索引): 也称为non-clustering index（非聚集索引）.它决定的顺序与文件实际排列的顺序不一样.
    <div align="center">
    <img src="../../../image/i201.png" width="100%"></div>

- Index-sequential file（索引顺序文件）: ordered sequential file with a primary index.


- Dense Index Files(稠密索引文件): 所有的Search Key都有一个索引条目.每个索引条目都指向一个数据记录.
    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
        <div>
            <img src="../../../image/i202.png" width="100%">
            <p align="center">稠密索引</p>
        </div>
        <div>
            <img src="../../../image/i203.png" width="100%">
            <p align="center">稀疏索引</p>
        </div>
    </div>

<!-- <div align="center" style="display:flex; justify-content:center;">
    <img src="../../../image/i202.png" width="48%" style="margin-right:2%;">
    <img src="../../../image/i203.png" width="48%">
</div> -->

- Sparse Index Files(稀疏索引文件): 只有一部分Search Key有索引条目.每个索引条目都指向一个数据块.
    <div align="center">
    <img src="../../../image/i204.png" width="100%"></div>

    - Good tradeoff: sparse index with an index entry for every block in file, corresponding to least search-key value in the block.

    - 和B+树有点像.

## Multilevel Index (多级索引)

- Treat primary index kept on disk as a sequential file and construct a sparse index on it.
    - outer index – a sparse index of primary index
    
    - inner index – the primary index file

<div align="center">
<img src="../../../image/i205.png" width="100%"></div>

## B+-Tree Index

和[ADS](../ADS/Tree.md#b树)一样

一个B+树节点典型的结构如下:

<div align="center">
<img src="../../../image/i206.png" width="100%"></div>

- $K_i$是搜索键的值.通常$K_1<K_2<...<K_{n-1}$

- $P_i$是指向下一个节点的指针.如果是叶子节点,那么$P_i$指向数据记录.如果是非叶子节点,那么$P_i$指向下一个节点.

- 对于叶子节点,$P_n$指向下一个叶子节点,也就是下一个数据记录.

### Examples

由于ADS中已经学过相关操作,所以这里就放一些B+树的例子.

#### B+ Tree

对于下图的B+树:

<div align="center">
<img src="../../../image/i207.png" width="100%"></div>

1. 其阶数n=6

2. 叶子节点的键值数目范围是[3,5]

3. 非叶子节点的孩子数目范围是[3,6] **这里和ADS不一样,是[(n-1)/2,n-1]**

4. 根节点要么是叶子,要么至少有两个孩子


!!! info "高度结论"
    如果一个B+树中存储了$K$个索引,则其高度的范围是:

    $$
    max{\lceil \log_{n/2} {K/2} \rceil +1 ,\lceil \log_{n/2} K \rceil }\geq h \geq \lceil \log_{n} K \rceil$$
    $$

#### 插入与删除

??? example "所有的例子"
    === "插入1"
        ![](../../image/i208.png)
    === "插入2"
        ![](../../image/i209.png)
    === "插入3"
        ![](../../image/i213.png)
    === "插入4"
        ![](../../image/i214.png)
    === "删除1"
        ![](../../image/i210.png)
    === "删除2"
        ![](../../image/i211.png)
    === "删除3"
        ![](../../image/i212.png)
    === "删除4"
        ![](../../image/i215.png)
    === "删除5"
        ![](../../image/i216.png)

> Average node occupancy depends on insertion order
> 
> $\frac{2}{3}$  with random, $\frac{1}{2}$with insertion in sorted order

### B+- tree : height and size estimation

对于如下的数据定义:

```sql
person( pid char(18)  primary key，
        name char(8),   
        age smallint,                             
        address char(40) ); 
```

与1000000个人相关的记录.

一个block大小4KB,一个指针大小8B,一个char(18)大小18B,一个char(8)大小8B,一个smallint大小2B,一个char(40)大小40B.

因此一个block可以存储的记录数为:

$$
\frac{4096}{8+18+2+40}=\frac{4096}{68}\approx 60
$$

B+树的阶数为:

$$
\frac{4096-4}{18+4}+1=\frac{4092}{22}+1\approx 187
$$

如果是两层的B+树,那么最多可以存储的记录数为:

$$
187*186\approx 34782
$$

如果是三层的B+树,那么最多可以存储的记录数为:

$$
187*187*186\approx 6504234
$$

因此我们使用三层的B+树,可以存储下上面这一百万条记录.

> 一个叶子可以存储[93,186]条记录,一个非叶子节点可以有[94,187]个孩子

1. 半满叶节点情况

    | 节点层级 | 计算值 | 向上取整 | 单位 |
    |---------|--------|---------|------|
    | 叶节点数 | 10752.69 | 10752 | nodes |
    | 第二层节点数 | 114 | 114 | nodes |
    | 根节点 | 1 | 1 | node |
    | **总节点数(最多)** | **10867** | **10867** | **nodes** |

2. 满叶节点情况

    | 节点层级 | 计算值 | 向上取整 | 单位 |
    |---------|--------|---------|------|
    | 叶节点数 | 5376.344 | 5377 | nodes |
    | 第二层节点数 | 29 | 29 | nodes |
    | 根节点 | 1 | 1 | node |
    | **总节点数(最小)** | **5407** | **5407** | **nodes** |

### B+ Tree File Organization

- B+-Tree File Organization:
    - Leaf nodes in a B+-tree file organization store records, instead of pointers.存储记录而不是指针

    - Helps keep data records clustered even when there are insertions/deletions/updates

- Leaf nodes are still required to be half full
    - Since records are larger than pointers, the maximum number of records that can be stored in a leaf node is less than the number of pointers in a nonleaf node.

<div align="center">
<img src="../../../image/i217.png" width="100%"></div>

### Other Issues in Indexing


- Record relocation and secondary indices
    - If a record is relocated, all secondary indices on the record must be updated.

    - 这会导致节点的分裂开销十分大

    - 解决方法是:在二级索引中不要直接存储记录地址，而是存储该记录的“主键”值，再通过主索引定位记录。

- Variable length strings as keys
    - Variable fanout

- Prefix compression
    - Keys in leaf node can be compressed by sharing common prefixes

    - Keep enough characters to distinguish entries in the subtrees separated by the key value
        - E.g. “Silas” and “Silberschatz” can be separated by “Silb”

## Bulk Loading and Bottom-Up Build
> 批量加载和自底向上构建


Inserting entries one-at-a-time into a B+-tree requires  1 IO per entry

因此,我们有两种解决方法:

1.  Insert in sorted order
    
    - 充分利用数据局部性.

2.  Bottom-up B+-tree construction

    - 和上面一样,先排序

    - 然后从底部开始构建B+-树

!!! example "Bulk Loading"
    ![](../../image/i218.png)


### Bulk insert index entries

!!! example "Bulk Insert"
    ![](../../image/i219.png)

    先把之前那颗树的叶子节点找到,1 Seek+6 blocks

    然后构建完树后,把树再写回去,1 Seek+13 blocks

### Multiple-Key Access

- Composite search keys are search keys containing more than one attribute
    - E.g. (dept_name, salary)

- Lexicographic ordering: (a1, a2) < (b1, b2) if either 
    - a1 < b1, or 
    
    - a1=b1 and  a2 < b2

## Indexing in Main Memory
