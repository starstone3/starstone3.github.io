---
comments : true
---

# 概述

## 什么是操作系统
> 计算机系统由硬件和应用程序组成。硬件（如CPU、内存、输入/输出设备等）为系统提供了基础的计算能力。应用程序（如文字处理、电子表格、编译器、浏览器等）则利用这些硬件资源来完成各种任 务，满足用户的需求。
>
> 操作系统的作用，就是在硬件和应用程序之间起桥梁作用。它负责管理和分配硬件资源，协调各个应用程序的运行，确保系统高效、稳定地工作。
>
> 简单来说，**操作系统**（Operating System, OS）是一组管理计算机硬件和软件资源的程序。它为用户和应用程序提供了一个方便的操作界面和运行环境，是计算机系统中最核心、最基础的软件。

正如下图所示,电脑系统可以分为以下四部分:

<div align="center">
    <img src="../../../image/mac99.png" width="80%"/>
    <br>
    <caption>电脑架构示意图</caption>
</div>

!!! tip "三个角度看操作系统"
    === "计算机系统组成"
        操作系统是一个系统软件,它位于硬件和应用程序之间,负责管理和协调计算机系统的各个部分。它有以下作用:

        + **资源管理者：**统一管理和分配硬件资源，避免冲突和浪费。

        + **运行环境提供者：**为应用程序提供一个标准的、方便的运行环境。

        + **用户接口：**为用户提供操作计算机的界面（如命令行、图形界面）。

        + **系统协调者：**协调多个应用程序的运行，保证系统的稳定和高效。
    === "用户"
        操作系统让用户能够方便地使用计算机。通过操作系统提供的界面，用户可以执行各种任务，如文件管理、程序运行、网络连接等，而不需要了解底层的硬件细节。

        操作系统提供的接口有:

        - **命令级接口：**:键盘、鼠标,触摸屏等

        - **程序级接口：**:API,系统调用等

    === "系统"
        操作系统是计算机资源的管理者,它负责协调和分配计算机的硬件资源（如CPU、内存、存储设备等）给不同的应用程序使用。操作系统通过调度算法和内存管理技术，确保各个程序能够高效地运行，同时避免资源冲突和浪费。

## 操作系统的发展历程

!!! info "Timeline"
    === "手工操作阶段"
        在这个阶段下,计算机的所有操作都需要人工干预,包括程序的输入、输出和存储等。不存在现在意义下的操作系统

    === "批处理阶段"
        计算机开始支持批处理作业.

        === "单道批处理"
            **核心思想**：为了实现作业的连续处理，系统将一批作业预先以脱机方式输入到磁带中，并配置监督程序（Monitor）来控制作业的自动执行。

            **工作流程**：
            ```
            磁带作业队列 → 监督程序调度 → 内存中单个作业执行 → 完成后调入下一个作业
            ```

            **主要特征**：
            
            1. **自动性**：在正常情况下，磁带上的作业能够自动逐个运行，无需人工干预
            2. **顺序性**：作业按照在磁带上的顺序依次进入内存执行，先调入的作业先完成
            3. **单道性**：内存中同时只能驻留一道程序，监督程序每次只调入一个程序运行

            **存在的问题**：
            
            !!! warning "CPU资源浪费严重"
                当程序运行过程中发出I/O请求时，高速的CPU必须等待低速的I/O操作完成，导致CPU长时间空闲。这种"CPU等待I/O"的现象严重降低了系统资源利用率。

            为了解决这一问题，后来引入了多道程序技术，允许多个程序同时驻留在内存中，CPU可以在等待某个程序I/O操作时切换到其他程序继续执行。

        === "多道批处理"
            用户的所有任务在硬盘上排列在一起,控制程序每次将一些任务调入内存中.当一个任务因I/O操作而等待时,CPU可以调度另一个任务运行,从而提高了CPU的利用率.

            因此,我们可以发现,多道批处理的特点是:

            + **宏观上并行**:多个任务在内存中同时存在,它们都没有完成,可以被调度运行.

            + **微观上串行**:在某一时刻,CPU只能运行一个任务,其他任务都处于等待状态.

        !!! example "例题：单道与多道批处理系统的CPU利用率对比"
            **题目描述**：
            
            有两个程序需要执行，它们的资源使用顺序如下：
            
            - **程序A**：CPU 10s → 设备甲 5s → CPU 5s → 设备乙 10s → CPU 10s

            - **程序B**：设备甲 10s → CPU 10s → 设备乙 5s → CPU 5s → 设备乙 10s
            
            那么

            1. 在单道程序环境下（先执行程序A，再执行程序B），CPU的利用率是多少？

            2. 在多道程序环境下，CPU利用率是多少？
            
            ??? tip "解"
                **单道程序环境分析**：
                
                程序必须串行执行，总执行时间为两个程序时间之和：
                - 程序A总时间：10 + 5 + 5 + 10 + 10 = 40s
                - 程序B总时间：10 + 10 + 5 + 5 + 10 = 40s
                - 系统总时间：40 + 40 = 80s
                - CPU总使用时间：(10 + 5 + 10) + (10 + 5) = 40s
                - **CPU利用率 = 40s / 80s = 50%**
                
                **多道程序环境分析**：
                
                两个程序可以并发执行，当一个程序等待I/O时，CPU可以调度另一个程序：
                
                ![](../../image/mac100.png)
                
                CPU运行时间40s,两个程序运行总时间45s,因此:
                
                - **CPU利用率 = 40s / 45s ≈ 88.9%**

                - **多道程序环境下CPU利用率明显高于单道程序环境的50%**
    === "分时阶段"
        **分时技术**指的是将处理器的运行时间分成很短的时间片,分配给各任务.若某个任务在给它分配的时间片内不能完成任务,则暂停该任务,将处理器分配给下一个任务.这样,每个任务都能在很短的时间内得到响应,从而实现了多个用户对计算机的交互式使用.

        **分时操作系统**允许多个用户使用终端共同使用一台电脑,其关键特点是使用户能与自己的作业进行交互,即当用户在自己的终端上键入命令时,系统能及时接收并及时处理该命令.其主要特征如下:

        1. 同时性。也称多路性,指允许多个终端用户同时使用一台计算机。  
        
        2. 交互性。用户通过终端采用人机对话的方式直接控制程序运行,与同程序进行交互。

        3. 独立性。系统中多个用户可以彼此独立地进行操作,互不干扰,单个用户感觉不到别人也在使用这台计算机,好像只有自己单独使用这台计算机一样。  
        
        4. 及时性。用户请求能在很短时间内获得响应。

---

## 操作系统的运行


### 处理器的运行环境

CPU会运行两种不同性质的程序:

1. **用户程序**: 由用户编写和运行的程序,如应用软件、游戏等.这些程序通常运行在用户态,权限受限,不能直接访问硬件资源.

2. **系统程序**: 由操作系统提供的程序,如文件管理、内存管理、设备驱动等.这些程序通常运行在内核态,权限较高,可以直接访问硬件资源.

它们之间最明显的区别就是,能否使用特权指令(Privileged Instruction)如访问硬件设备、管理内存等.

操作系统的内核(Kernel)实际上是一个程序,负责了以下四种功能:

1. 时钟管理,负责维护系统的时钟信息,提供时间片轮转等调度策略.

2. 中断机制的维护,负责处理各种中断请求,如I/O中断、定时器中断等.

3. 硬件原语的封装,提供对硬件设备的统一接口,如文件系统、网络协议等.

4. 进程、设备的管理,负责创建、销毁、调度进程,管理设备的使用等.



### 中断(Interrupt)

正如在计组和体系中学过的, 中断是一种机制，它允许外部设备或内部事件向CPU发送信号，以便引起CPU的注意并请求服务。当CPU正在执行某个程序时，如果发生中断，CPU会暂停当前程序的执行，保存其状态，并转而执行中断处理程序。相关的概念有:

+ **mepc寄存器**: 用于保存发生中断时的程序计数器(PC)的值,以便中断处理完成后能够返回到正确的位置继续执行.

+ **中断向量表**: 是一个存储中断处理程序入口地址的数据结构。每个中断类型都有一个对应的入口地址，当中断发生时，CPU可以通过查找中断向量表来找到相应的处理程序。

+ **mcause寄存器**: 用于保存引起中断的原因代码,以便中断处理程序能够根据不同的中断类型采取相应的措施.

+ **mtval寄存器**: 用于保存与中断相关的附加信息,如发生地址等.

在这里,我们可以理解到中断更深层的含义.正如上面所说,程序的运行有内核态和用户态之分.用户态下的程序无法使用内核态的指令,当它们有时候又必须使用这些功能,比如读写文件,访问网络等,这时候就需要通过中断来实现从用户态切换到内核态,以便使用这些特权指令.

也就是说,发生中断时,CPU会从用户态切换到内核态,执行相应的中断处理程序,完成所需的操作后,再切换回用户态,继续执行用户程序.

<div align="center">
    <img src="../../../image/mac101.png" width="80%"/>
    <br>
    <caption>中断的分类</caption>
    </div>


!!! info "Exception and Interrupt"
    === "trap/fault"
        + **Trap**: 是一种同步事件,它是在程序执行过程中由程序本身引发的,如系统调用、调试断点等.当trap发生时,CPU会暂停当前程序的执行,保存其状态,并转而执行相应的trap处理程序.

        + **Fault**: 也是一种同步事件,它是在程序执行过程中由程序本身引发的,如非法内存访问、除零错误等.当fault发生时,CPU会暂停当前程序的执行,保存其状态,并转而执行相应的fault处理程序.

        + **Abort**: 是一种严重的同步事件,它通常是由硬件故障引起的,如内存错误、总线错误等.当abort发生时,CPU会立即停止当前程序的执行,并转而执行相应的abort处理程序.

        Trap和fault都是由程序本身引发的,因此它们是同步事件,而abort通常是由硬件故障引起的,因此它是一种异步事件.

    === "interrupt"
        中断是一种异步事件,它可以在任何时候发生,与当前正在执行的程序无关.中断通常由外部设备(如键盘、鼠标、网络接口等)或内部事件(如定时器中断)引起.当中断发生时,CPU会暂停当前程序的执行,保存其状态,并转而执行相应的中断处理程序.

        对于interrupt,还有可屏蔽中断与不可屏蔽中断的区分,这是为了区分中断的优先级.
        
        
        不可屏蔽中断(interrupt)通常是由严重的硬件故障引起的,如电源故障、内存错误等,通过NMI(Non-Maskable Interrupt)线发出信号.当不可屏蔽中断发生时,CPU必须立即响应,无法通过软件手段屏蔽或延迟处理.

        可屏蔽中断(interrupt)通常是由外部设备或内部事件引起的,如键盘输入、鼠标点击、网络数据到达等,通过INTR(Interrupt Request)线发出信号.当可屏蔽中断发生时,CPU可以根据当前的优先级设置决定是否响应,可以通过软件手段屏蔽或延迟处理.

        interrupt多由硬件引起

### 系统调用(System Call)

系统调用是用户程序与操作系统内核之间进行交互的接口。它允许用户程序请求操作系统提供特权服务，如文件操作、进程管理、内存分配等。也就是说,凡是这种特权服务,都需要让用户先向操作系统发出请求,然后让操作系统完成这些服务,然后操作系统把结果返回给用户.

1. 用户程序发起系统调用

    + 用户程序将系统调用号和参数压入堆栈。
    + 执行系统调用指令（如 syscall 或 int 指令）。
    + CPU执行陷入（trap）指令，状态从用户态切换到内核态。

2. 内核接管控制权

    + 硬件和操作系统内核保存当前进程的现场（如程序计数器PC、程序状态字PSW、通用寄存器等）。
    
    + 根据系统调用号，查找系统调用入口表，跳转到对应的系统调用处理子程序。

3. 系统调用处理

    + 内核执行相应的系统调用处理逻辑（如文件操作、进程管理等）。

4. 返回用户程序

    + 系统调用处理完成后，恢复被中断进程（或新进程）的CPU现场。
    + CPU状态从内核态切换回用户态，继续执行用户程序。

<div align="center">
    <img src="../../../image/mac110.png" width="80%"/>
    <br>
    <caption>系统调用的工作流程</caption>
</div>

## 操作系统结构

!!! info "几种操作系统的结构"
    === "分层法"
        分层法的思想和网络体系结构类似,每一层只能与相邻的上下两层进行通信.每一层都为它的上一层提供服务,而它自己则向下一层请求服务.

        层0为硬件,最外层是用户接口

        <div align="center">
            <img src="../../../image/mac111.png" width="60%"/>
            <br>
            <caption>分层法结构示意图</caption
            </div>
        
        分层法的设计思想清晰,便于理解和实现,但层与层之间的通信开销较大,影响系统性能,并且每一层的功能比较难定义

    === "模块化结构"

        模块化结构将操作系统按照功能划分为若干模块,每个模块实现特定的功能,模块之间通过接口进行通信.这种结构灵活性较高,便于维护和扩展.
        <div align="center">
            <img src="../../../image/mac112.png" width="60%"/>
            <br>
            <caption>模块化结构示意图</caption>
        </div>

        如果各个模块太小,则,模块之间的联系会比较多而混乱,若模块太大,则,模块内部的功能会比较复杂,不易理解和维护.

        衡量模块的独立性主要有两个标准:  
        
        - 内聚性,模块内部各部分间联系的紧密程度。内聚性越高,模块独立性越好。 
        
        - 耦合度,模块间相互联系和相互影响的程度。耦合度越低,模块独立性越好。

        模块化的缺点在于各模块之间一起设计,难以保证兼容性


    === "宏内核"
        宏内核(Monolithic Kernel)结构将操作系统的所有核心功能都集成在一个单一的内核中,包括进程管理、内存管理、文件系统、设备驱动等.这种结构的优点是性能较高,因为所有功能都在内核空间中运行,减少了用户态和内核态之间的切换开销.

        然而,随着操作系统的发展,宏内核的缺点也逐渐显现出来.由于所有功能都集成在一个内核中,内核变得庞大而复杂,难以维护和扩展.此外,宏内核的稳定性较差,一个模块的错误可能导致整个系统崩溃.

    === "微内核"
        微内核(Microkernel)结构将操作系统的核心功能划分为多个独立的模块,只保留最基本的功能在内核中,如进程管理、内存管理和进程间通信等.其他功能如文件系统、设备驱动等则作为用户态的服务运行.

        微内核结构将操作系统分为微内核与多个服务器两部分.微内核部分通常包含:

        1. 硬件处理紧密相关的部分
        
        2. 操作系统基本的功能
        
        3. 处理客户和服务器之间的通信的功能


        因此,可以总结出微内核的核心功能:

        1. **进程(线程)管理**

            - **机制部分（微内核）**：进程通信、进程切换、进程调度、多处理机同步、进程优先级队列等基础机制

            - **策略部分（外部服务器）**：用户进程分类、优先级确定方式等调度策略

        2. **低级存储器管理**
            - **机制部分（微内核）**：页表机制、地址变换机制等硬件相关的基础功能
            - **策略部分（外部服务器）**：页面置换算法、内存分配与回收策略等虚拟存储管理策略

        3. **中断和陷入处理**

            - **机制部分（微内核）**：捕获中断/陷入事件、中断响应处理、事件识别

            - **策略部分（外部服务器）**：具体的中断/陷入事件处理逻辑


        微内核将传统操作系统的三大功能模块（进程管理、存储器管理、I/O管理）进行**功能分离**：

        - **微内核**：只保留最小的机制部分

        - **外部服务器**：承担大部分策略实现，通常比微内核更大
        
        微内核结构中,只有微内核运行在内核态,服务器则运行在用户态.这样,即使某个服务器出现故障,也不会影响整个系统的稳定性.

        现代操作系统通常采用混合结构,结合了宏内核和微内核的优点,以实现更好的性能和灵活性.

---

操作系统的引导过程:

1. 激活CPU
    - CPU上电后自动激活

    - 读取ROM中的boot程序

    - 将指令寄存器置为BIOS(基本输入/输出系统)的第一条指令

    - 开始执行BIOS指令

2. 硬件自检
    - **构建中断向量表**：BIOS程序在内存最开始的空间构建中断向量表

    - **POST过程**：执行通电自检(Power-On Self-Test)，检查硬件是否出现故障

    - **故障处理**：

        - 有故障：主板发出不同含义的蜂鸣声，启动中止
    
        - 无故障：屏幕显示CPU、内存、硬盘等信息

3. 加载带有操作系统的硬盘

    - 通电自检完成后，BIOS读取Boot Sequence

    - 启动顺序来源：CMOS保存的启动顺序或用户交互选择

    - 将控制权交给启动顺序排在第一位的存储设备

    - CPU将该存储设备引导扇区的内容加载到内存中


4. 加载主引导记录(MBR)
    - 硬盘通过特定标识符区分引导硬盘和非引导硬盘

    - 若发现存储设备不是可引导盘，检查下一个存储设备

    - 如无其他启动设备，系统死机

    - **MBR作用**：告诉CPU去硬盘的哪个主分区寻找操作系统

5. 扫描硬盘分区表，加载硬盘活动分区
    - MBR包含硬盘分区表

    - 硬盘分区表通过特定标识符区分活动分区和非活动分区

    - 主引导记录扫描硬盘分区表，识别含有操作系统的硬盘分区(活动分区)

    - 找到硬盘活动分区后，开始加载并将控制权交给活动分区

6. 加载分区引导记录(PBR)

    - 读取活动分区的第一个扇区，即分区引导记录(Partition Boot Record)

    - **PBR作用**：寻找并激活分区根目录下用于引导操作系统的程序(启动管理器)

7. 加载启动管理器
    - 分区引导记录搜索活动分区中的启动管理器

    - 加载启动管理器，完成操作系统的最终引导

8. 将操作系统加载到内存中去

```
CPU激活 → BIOS执行 → 硬件自检(POST) → 读取Boot Sequence → 
加载MBR → 扫描分区表 → 加载活动分区 → 加载PBR → 启动管理器 → 加载操作系统
```

---


## 虚拟机
> 虚拟机指的是在一台物理计算机上通过软件模拟出多个独立的计算机系统,每个虚拟机都可以运行自己的操作系统和应用程序,就像在独立的物理计算机上一样.

### 第一类虚拟机管理系统

第一类虚拟机管理系统(Type 1 Hypervisor)直接运行在物理硬件上,可以说就是一个操作系统,它向上提供了若干虚拟机,向下则直接管理硬件资源.第一类虚拟机管理系统通常用于服务器环境,如VMware ESXi、Microsoft Hyper-V等.

由于Hypervisor直接访问硬件，没有中间操作系统层消耗资源，所以性能非常高，资源开销小。虚拟机可以近乎以本地速度运行。

<div align="center">
    <img src="../../../image/mac113.png" width="80%"/>
    <br>
    <caption>第一类虚拟机管理系统示意图</caption>
</div>

第一类虚拟机也叫裸金属虚拟机(Bare-Metal Hypervisor),因为它直接运行在物理硬件上,没有中间操作系统层.


虚拟机实际上是作为用户态的一个进程而运行,然而,虚拟机上的操作系统会认为自己处于内核态(虚拟内核态).因此,当这些操作系统执行了在内核态才能执行的指令时,会由虚拟机管理程序捕获并检查.

**特权指令处理机制**：
当虚拟机内的操作系统执行特权指令时，虚拟机管理程序会捕获并检查这些指令：

1. **指令来源判断**：
   - 如果指令来自虚拟机中的操作系统，虚拟机管理程序会安排指令的正确执行
   
   - 如果指令来自用户程序，虚拟机管理程序会模拟真实硬件处理用户态执行敏感指令时的行为

2. **虚拟化支持**：
   在支持虚拟化的CPU上，这种检查和处理机制能够高效地维护虚拟机的正确运行。

### 第二类虚拟机管理系统

第二类虚拟机管理系统(Type 2 Hypervisor)运行在一个宿主操作系统上,它依赖于宿主操作系统来管理硬件资源.第二类虚拟机管理系统通常用于桌面环境,如VMware Workstation、Oracle VirtualBox等.

<div align="center">
    <img src="../../../image/mac114.png" width="80%"/>
    <br>
    <caption>第二类虚拟机管理系统示意图</caption>
</div>


---

虚拟机里的操作系统被称为**客户操作系统(Guest OS)**,而运行虚拟机管理程序的操作系统被称为**宿主操作系统(Host OS)**.