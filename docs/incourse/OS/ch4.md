---
comments: true
---

# 内存管理
> MMU负责把虚拟地址转换成物理地址

## 程序的装入与链接
用户程序要在系统中运行，必须先将程序和数据装入内存。主要经过以下三个步骤：

1. **编译 (Compile)**：将源代码编译成目标模块。

2. **链接 (Link)**：将目标模块和库函数链接成装入模块。
3. **装入 (Load)**：将装入模块装入内存。

### 装入方式

* **绝对装入 (Absolute Loading)**

    * **特点**：编译时就确定了绝对地址。

    * **适用**：单道程序环境。

* **可重定位装入 (Static Relocation)**

    * **特点**：在**装入时**一次性完成地址转换。

    * **缺点**：作业装入后不能移动，也不能动态申请内存。

* **动态运行时装入 (Dynamic Relocation)**

    * **特点**：在**程序执行时**才进行地址转换。

    * **硬件支持**：需要**重定位寄存器**。

    * **优点**：允许程序移动（便于紧凑），支持动态申请内存，便于共享。

### 链接方式

* **静态链接 (Static Linking)**

    * 运行前链接成完整程序。

* **装入时动态链接 (Load-time Dynamic Linking)**

    * 边装入边链接。便于更新和共享。

* **运行时动态链接 (Run-time Dynamic Linking)**

    * **执行到该模块时**才进行链接。

    * **优点**：加快装入，节省内存（未用到的模块不装入）。

## Swapping (交换技术)
交换技术的原理非常简单：进程可以暂时从内存中被调出 (Swap Out) 到磁盘的交换区，在之后需要运行的时候再加载回内存 (Swap In)。

!!! info 
    1. **交换区 (Backing Store)**
    
        * 通常是磁盘上的一个独立分区（如 Linux Swap）。
        * 为了追求速度，通常直接管理磁盘块，不经过普通文件系统。

    2. **性能开销**
    
        * 主要瓶颈是**磁盘 I/O 传输时间**。
        
        * 传输时间与**被交换出的内存大小**成正比。
        
        * **优化**：只在内存吃紧时启动；只交换阻塞/睡眠状态的进程。

    3. **挂起的 I/O (Pending I/O) 问题**

        * **场景**：进程 A 正在等待 I/O（如读磁盘数据到缓冲区），此时若将 A 换出，内存分给进程 B。I/O 设备回来写数据时，会错误地写入 B 的空间。

        * **解决方案**：

            * **禁止交换**：有挂起 I/O 的进程不准换出。
            * **双重缓冲 (Double Buffering)**：I/O 操作使用**内核缓冲区**。数据先到内核，再拷贝到用户进程。这样用户进程随时可换出。

    4. **现代 OS 的交换**
        
        * **标准交换**（移动整个进程）已很少使用。
        
        * 现代系统多结合**分页**，只交换页面 (Pages)。
        
        * **移动端 (iOS/Android)**：通常**不支持**交换（闪存寿命 & 空间限制），内存不足时直接杀后台进程。

## 连续内存分配
> 连续内存分配指的是为用户进程分配一个连续的内存空间来运行

### 单一连续分配

在本方法中,内存被分为两部分,低地址的系统区与高地址的用户区.

其中:

- 基址寄存器保存了最低的物理地址

- 限长寄存器保存了地址范围

在一个用户程序访问内存时,MMU会根据基址寄存器和限长寄存器来判断访问是否合法,并将访问的地址转换为物理地址.

这种方法的缺点是只适用于单道程序环境,无法实现进程的隔离.

### 固定分区分配

这种方法的思想是,把内存空间划分为一个个固定的块,每个块可以容纳一个进程.

<div style="text-align: center;">
    <img src="../../../image/mac206.png" width="80%">
    <br>
    <caption>固定分区分配</caption>
</div>

划分分区时有两种不同的方法。 

- 分区大小相等。程序太小会造成浪费,程序太大又无法装入。 

- 分区大小不等。划分为多个较小的分区、适量的中等分区和少量大分区。

显然,这个方法会带来内部碎片的问题.当程序小于固定的分区大小时,会浪费掉剩余的空间.

### 动态分区分配

动态分区分配不预先划分内存，而是在进程装入内存时，根据进程的实际大小，动态地建立分区。

*   **特点**：分区的大小和数目是可变的。

*   **缺点**：会产生**外部碎片**（内存中存在许多细小的空闲块，但无法利用）。
> 虽然外部碎片可以通过紧凑技术（Compaction）来解决，但紧凑技术会带来额外的开销。


!!! definition
    - 内部碎片(Internal Fragmentation)：在进程内存空间中的未利用的碎片.例如，一个进程需要 100KB 的内存，但分配到的分区大小是 128KB，那么 28KB 就是内部碎片。
    
    - 外部碎片(External Fragmentation)：在进程分配到的内存之间的碎片.
      
        **例子**：系统总空闲内存 70MB，但被分为不连续的 40MB 和 30MB 两块。此时若有进程需要 50MB，虽然总空闲够，但无法满足，这 40MB 和 30MB 就是外部碎片。

#### 数据结构
操作系统需要记录哪些内存是空闲的，常用的数据结构有：

*   **空闲分区表 (Free Partition Table)**：每个表项记录一个空闲分区的起始地址和长度。
*   **空闲分区链 (Free Partition List)**：将空闲分区通过指针连成链表。

#### 分配算法 (Allocation Algorithms)

分配算法负责选择一个空闲分区来分配给作业。

| 算法 | 策略 | 优点 | 缺点 |
| :--- | :--- | :--- | :--- |
| **首次适应 (First Fit)** | 从低地址开始查找，找到**第一个**能满足大小的空闲分区。 | **最快**（通常性能最好）；保留了高地址的大块空闲区。 | 低地址部分容易产生细小碎片；每次查找都从头开始，增加查找开销。 |
| **最佳适应 (Best Fit)** | 查找**满足要求且最小**的空闲分区。 | 每次分配后剩余的碎片最小。 | 产生大量无法利用的**微小碎片**（外部碎片）；需要对空闲区排序（按大小递增）。 |
| **最坏适应 (Worst Fit)** | 查找**满足要求且最大**的空闲分区。 | 每次分配后剩余的空闲区仍较大，可能还能用。 | **大块空闲区被迅速拆散**，后续大作业来了没地放；需要排序（按大小递减）。 |
| **邻近适应 (Next Fit)** | 从**上次查找结束的位置**开始继续查找（循环扫描）。 | 减少查找开销；空闲分区分布更均匀。 | 高地址的大块空闲区也被拆散了。 |

#### 紧凑 (Compaction)

为了解决**外部碎片**问题，可以将内存中所有作业移动到一端，使原本分散的空闲小分区拼接成一个大分区。

*   **前提**：系统必须支持**动态重定位**（运行时动态装入）。

*   **代价**：需要移动大量数据，CPU 开销大。

## 分页分配

固定分区分配会产生内部碎片,而动态分区分配又会产生外部碎片,我们希望这两种碎片尽可能的少,因此产生了分页技术


*   **页框 (Frames)**：

    *   将**物理内存**划分为固定大小的块，称为**页框**（或帧、物理块）。
    *   大小通常是 2 的幂，介于 512 字节到 8192 字节之间。

    *   **实例**：Linux 和 Windows (x86) 通常使用 **4KB**。

*   **页 (Pages)**：

    *   将**逻辑内存**划分为与页框大小相同的块，称为**页**。

地址转换的逻辑在很多课里都学过,流程为:

1.  **分解逻辑地址**：CPU 生成的逻辑地址被自动划分为两部分：

    *   **页号 (Page Number, p)**：用于索引页表。

    *   **页内偏移量 (Page Offset, d)**：表示该地址在页内的位置（不改变）。

2.  **查页表 (Lookup Page Table)**：以页号 $p$ 为索引，去查找**页表**。

3.  **获取页框号**：从对应的页表项中取出该页所在的**物理页框号 (Frame Number, f)**。

4.  **合成物理地址**：将物理页框号 $f$ 与页内偏移量 $d$ 拼接（或者说：物理地址 = $f \times \text{页大小} + d$）。
